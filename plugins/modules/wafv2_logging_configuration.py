#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright: (c) 2022, Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
# template: header.j2
# This module is autogenerated using the ansible.content_builder.
# See: https://github.com/ansible-community/ansible.content_builder


DOCUMENTATION = r"""
module: wafv2_logging_configuration
short_description: Creates and manages an association between logging destinations
    and a web ACL resource
description:
- Creates and manages an association between logging destinations and a web ACL resource,
    for logging from AWS WAF.
- For more information see U(https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-wafv2-loggingconfiguration.html).
options:
    force:
        default: false
        description:
        - Cancel IN_PROGRESS and PENDING resource requestes.
        - Because you can only perform a single operation on a given resource at a
            time, there might be cases where you need to cancel the current resource
            operation to make the resource available so that another operation may
            be performed on it.
        type: bool
    log_destination_configs:
        aliases:
        - LogDestinationConfigs
        description:
        - The Amazon Resource Names (ARNs) of the logging destinations that you want
            to associate with the web ACL.
        elements: str
        type: list
    logging_filter:
        aliases:
        - LoggingFilter
        description:
        - Filtering that specifies which web requests are kept in the logs and which
            are dropped.
        - You can filter on the rule action and on the web request labels that were
            applied by matching rules during web ACL evaluation.
        suboptions:
            default_behavior:
                aliases:
                - DefaultBehavior
                choices:
                - DROP
                - KEEP
                description:
                - Default handling for logs that dont match any of the specified filtering
                    conditions.
                type: str
            filters:
                aliases:
                - Filters
                description:
                - The filters that you want to apply to the logs.
                elements: dict
                suboptions:
                    behavior:
                        aliases:
                        - Behavior
                        choices:
                        - DROP
                        - KEEP
                        description:
                        - How to handle logs that satisfy the filters conditions and
                            requirement.
                        type: str
                    conditions:
                        aliases:
                        - Conditions
                        description:
                        - Match conditions for the filter.
                        elements: dict
                        suboptions:
                            action_condition:
                                aliases:
                                - ActionCondition
                                description:
                                - A single action condition.
                                suboptions:
                                    action:
                                        aliases:
                                        - Action
                                        choices:
                                        - ALLOW
                                        - BLOCK
                                        - CAPTCHA
                                        - CHALLENGE
                                        - COUNT
                                        - EXCLUDED_AS_COUNT
                                        description:
                                        - Logic to apply to the filtering conditions.
                                        - You can specify that, in order to satisfy
                                            the filter, a log must match all conditions
                                            or must match at least one condition.
                                        type: str
                                type: dict
                            label_name_condition:
                                aliases:
                                - LabelNameCondition
                                description:
                                - A single label name condition.
                                suboptions:
                                    label_name:
                                        aliases:
                                        - LabelName
                                        description:
                                        - The label name that a log record must contain
                                            in order to meet the condition.
                                        - This must be a fully qualified label name.
                                        - Fully qualified labels have a prefix, optional
                                            namespaces, and label name.
                                        - The prefix identifies the rule group or
                                            web ACL context of the rule that added
                                            the label.
                                        type: str
                                type: dict
                        type: list
                    requirement:
                        aliases:
                        - Requirement
                        choices:
                        - MEETS_ALL
                        - MEETS_ANY
                        description:
                        - Logic to apply to the filtering conditions.
                        - You can specify that, in order to satisfy the filter, a
                            log must match all conditions or must match at least one
                            condition.
                        type: str
                type: list
        type: dict
    redacted_fields:
        aliases:
        - RedactedFields
        description:
        - A key-value pair to associate with a resource.
        elements: dict
        suboptions:
            json_body:
                aliases:
                - JsonBody
                description:
                - Inspect the request body as JSON. The request body immediately follows
                    the request headers.
                - This is the part of a request that contains any additional data
                    that you want to send to your web server as the HTTP request body,
                    such as data from a form.
                suboptions:
                    invalid_fallback_behavior:
                        aliases:
                        - InvalidFallbackBehavior
                        choices:
                        - EVALUATE_AS_STRING
                        - MATCH
                        - NO_MATCH
                        description:
                        - What AWS WAF should do if it fails to completely parse the
                            JSON body.
                        type: str
                    match_pattern:
                        aliases:
                        - MatchPattern
                        description:
                        - The patterns to look for in the JSON body.
                        - AWS WAF inspects the results of these pattern matches against
                            the rule inspection criteria.
                        suboptions:
                            all:
                                aliases:
                                - All
                                description:
                                - Match all of the elements.
                                - See also I(match_scope) in I(json_body).
                                - You must specify either this setting or the I(included_paths)
                                    setting, but not both.
                                type: dict
                            included_paths:
                                aliases:
                                - IncludedPaths
                                description:
                                - Match only the specified include paths.
                                - See also I(match_scope) in I(json_body).
                                elements: str
                                type: list
                        type: dict
                    match_scope:
                        aliases:
                        - MatchScope
                        choices:
                        - ALL
                        - KEY
                        - VALUE
                        description:
                        - The parts of the JSON to match against using the I(match_pattern).
                        - If you specify All, AWS WAF matches against keys and values.
                        type: str
                type: dict
            method:
                aliases:
                - Method
                description:
                - Inspect the HTTP method.
                - The method indicates the type of operation that the request is asking
                    the origin to perform.
                type: dict
            query_string:
                aliases:
                - QueryString
                description:
                - Inspect the query string.
                - This is the part of a URL that appears after a ? character, if any.
                type: dict
            single_header:
                aliases:
                - SingleHeader
                description:
                - Inspect a single header.
                - Provide the name of the header to inspect, for example, User-Agent
                    or Referer.
                - This setting isnt case sensitive.
                suboptions:
                    name:
                        aliases:
                        - Name
                        description:
                        - The name of the query header to inspect.
                        type: str
                type: dict
            uri_path:
                aliases:
                - UriPath
                description:
                - Inspect the request URI path.
                - This is the part of a web request that identifies a resource, for
                    example, /images/daily-ad.jpg.
                type: dict
        type: list
    resource_arn:
        aliases:
        - ResourceArn
        description:
        - The Amazon Resource Name (ARN) of the web ACL that you want to associate
            with LogDestinationConfigs.
        type: str
    state:
        choices:
        - present
        - absent
        - list
        - describe
        - get
        default: present
        description:
        - Goal state for resource.
        - I(state=present) creates the resource if it doesn't exist, or updates to
            the provided state if the resource already exists.
        - I(state=absent) ensures an existing instance is deleted.
        - I(state=list) get all the existing resources.
        - I(state=describe) or I(state=get) retrieves information on an existing resource.
        type: str
    wait:
        default: false
        description:
        - Wait for operation to complete before returning.
        type: bool
    wait_timeout:
        default: 320
        description:
        - How many seconds to wait for an operation to complete before timing out.
        type: int
author: Ansible Cloud Team (@ansible-collections)
version_added: 0.3.0
extends_documentation_fragment:
- amazon.aws.aws
- amazon.aws.ec2
- amazon.cloud.boto3
"""

EXAMPLES = r"""
"""

RETURN = r"""
result:
    description:
        - When I(state=list), it is a list containing dictionaries of resource information.
        - Otherwise, it is a dictionary of resource information.
        - When I(state=absent), it is an empty dictionary.
    returned: always
    type: complex
    contains:
        identifier:
            description: The unique identifier of the resource.
            type: str
        properties:
            description: The resource properties.
            type: dict
"""


from ansible_collections.amazon.cloud.plugins.module_utils.core import (
    AnsibleAmazonCloudModule,
)
from ansible_collections.amazon.cloud.plugins.module_utils.core import (
    CloudControlResource,
)
from ansible_collections.amazon.cloud.plugins.module_utils.core import (
    ansible_dict_to_boto3_tag_list,
)
from ansible_collections.amazon.cloud.plugins.module_utils.core import (
    scrub_none_parameters,
)
from ansible_collections.amazon.cloud.plugins.module_utils.core import map_key_to_alias


def main():
    argument_spec = dict(
        state=dict(
            type="str",
            choices=["present", "absent", "list", "describe", "get"],
            default="present",
        ),
    )

    argument_spec["resource_arn"] = {"type": "str", "aliases": ["ResourceArn"]}
    argument_spec["log_destination_configs"] = {
        "type": "list",
        "elements": "str",
        "aliases": ["LogDestinationConfigs"],
    }
    argument_spec["redacted_fields"] = {
        "type": "list",
        "elements": "dict",
        "options": {
            "json_body": {
                "type": "dict",
                "options": {
                    "invalid_fallback_behavior": {
                        "type": "str",
                        "choices": ["EVALUATE_AS_STRING", "MATCH", "NO_MATCH"],
                        "aliases": ["InvalidFallbackBehavior"],
                    },
                    "match_pattern": {
                        "type": "dict",
                        "options": {
                            "all": {"type": "dict", "aliases": ["All"]},
                            "included_paths": {
                                "type": "list",
                                "elements": "str",
                                "aliases": ["IncludedPaths"],
                            },
                        },
                        "aliases": ["MatchPattern"],
                    },
                    "match_scope": {
                        "type": "str",
                        "choices": ["ALL", "KEY", "VALUE"],
                        "aliases": ["MatchScope"],
                    },
                },
                "aliases": ["JsonBody"],
            },
            "method": {"type": "dict", "aliases": ["Method"]},
            "query_string": {"type": "dict", "aliases": ["QueryString"]},
            "single_header": {
                "type": "dict",
                "options": {"name": {"type": "str", "aliases": ["Name"]}},
                "aliases": ["SingleHeader"],
            },
            "uri_path": {"type": "dict", "aliases": ["UriPath"]},
        },
        "aliases": ["RedactedFields"],
    }
    argument_spec["logging_filter"] = {
        "type": "dict",
        "options": {
            "default_behavior": {
                "type": "str",
                "choices": ["DROP", "KEEP"],
                "aliases": ["DefaultBehavior"],
            },
            "filters": {
                "type": "list",
                "elements": "dict",
                "options": {
                    "behavior": {
                        "type": "str",
                        "choices": ["DROP", "KEEP"],
                        "aliases": ["Behavior"],
                    },
                    "conditions": {
                        "type": "list",
                        "elements": "dict",
                        "options": {
                            "action_condition": {
                                "type": "dict",
                                "options": {
                                    "action": {
                                        "type": "str",
                                        "choices": [
                                            "ALLOW",
                                            "BLOCK",
                                            "CAPTCHA",
                                            "CHALLENGE",
                                            "COUNT",
                                            "EXCLUDED_AS_COUNT",
                                        ],
                                        "aliases": ["Action"],
                                    }
                                },
                                "aliases": ["ActionCondition"],
                            },
                            "label_name_condition": {
                                "type": "dict",
                                "options": {
                                    "label_name": {
                                        "type": "str",
                                        "aliases": ["LabelName"],
                                    }
                                },
                                "aliases": ["LabelNameCondition"],
                            },
                        },
                        "aliases": ["Conditions"],
                    },
                    "requirement": {
                        "type": "str",
                        "choices": ["MEETS_ALL", "MEETS_ANY"],
                        "aliases": ["Requirement"],
                    },
                },
                "aliases": ["Filters"],
            },
        },
        "aliases": ["LoggingFilter"],
    }
    argument_spec["state"] = {
        "type": "str",
        "choices": ["present", "absent", "list", "describe", "get"],
        "default": "present",
    }
    argument_spec["wait"] = {"type": "bool", "default": False}
    argument_spec["wait_timeout"] = {"type": "int", "default": 320}
    argument_spec["force"] = {"type": "bool", "default": False}

    required_if = [
        ["state", "present", ["resource_arn", "log_destination_configs"], True],
        ["state", "absent", ["resource_arn"], True],
        ["state", "get", ["resource_arn"], True],
    ]
    mutually_exclusive = []

    module = AnsibleAmazonCloudModule(
        argument_spec=argument_spec,
        required_if=required_if,
        mutually_exclusive=mutually_exclusive,
        supports_check_mode=True,
    )
    cloud = CloudControlResource(module)

    type_name = "AWS::WAFv2::LoggingConfiguration"

    params = {}

    params["log_destination_configs"] = module.params.get("log_destination_configs")
    params["logging_filter"] = module.params.get("logging_filter")
    params["redacted_fields"] = module.params.get("redacted_fields")
    params["resource_arn"] = module.params.get("resource_arn")

    # The DesiredState we pass to AWS must be a JSONArray of non-null values
    _params_to_set = scrub_none_parameters(params)

    # Only if resource is taggable
    if module.params.get("tags") is not None:
        _params_to_set["tags"] = ansible_dict_to_boto3_tag_list(module.params["tags"])

    # Use the alias from argument_spec as key and avoid snake_to_camel conversions
    params_to_set = map_key_to_alias(_params_to_set, argument_spec)

    # Ignore createOnlyProperties that can be set only during resource creation
    create_only_params = ["/properties/ResourceArn"]

    # Necessary to handle when module does not support all the states
    handlers = ["create", "read", "update", "delete", "list"]

    state = module.params.get("state")
    identifier = ["/properties/ResourceArn"]

    results = {"changed": False, "result": {}}

    if state == "list":
        if "list" not in handlers:
            module.exit_json(
                **results, msg=f"Resource type {type_name} cannot be listed."
            )
        results["result"] = cloud.list_resources(type_name, identifier)

    if state in ("describe", "get"):
        if "read" not in handlers:
            module.exit_json(
                **results, msg=f"Resource type {type_name} cannot be read."
            )
        results["result"] = cloud.get_resource(type_name, identifier)

    if state == "present":
        results = cloud.present(
            type_name, identifier, params_to_set, create_only_params
        )

    if state == "absent":
        results["changed"] |= cloud.absent(type_name, identifier)

    module.exit_json(**results)


if __name__ == "__main__":
    main()
